#!/usr/bin/env python2
# ROS
import rospy
from roslib import message
# movement
from geometry_msgs.msg import Twist
# point cloud library
import sensor_msgs.point_cloud2 as pc2
from sensor_msgs.msg import PointCloud2, PointField

_twist_publisher = rospy.Publisher('cmd_vel_mux/input/teleop', Twist)
# TODO incorrect node
_pcl_subscriber = rospy.Subscriber('camera/depth_registered/points', PointCloud2, pcl_callback)

## GLOBALS - move to another file if this becomes unwieldy
# this is always being updated in the background
LAST_PCL = None
# TODO
MIN_DISTANCE = 50

##

def pcl_callback(data):
	LAST_PCL = read_depth(int(data.width/2), int(data.height/2), data)

def read_depth(width, height, data):
	# read function
	if (height >= data.height) or (width >= data.width) :
		return -1
	data_out = pc2.read_points(data, field_names=None, skip_nans=False, uvs=[width, height])
	int_data = next(data_out)
	rospy.loginfo("int_data " + str(int_data))
	return int_data

def check_right():
	right()
	time.sleep(.5) # allow robot to gather data
	result = (MIN_DISTANCE < LAST_PCL)
	left()
	return result

def check_left():
	left()
	time.sleep(.5) # allow robot to gather data
	result = (MIN_DISTANCE < LAST_PCL)
	left()
	return result

def check_forward():
	time.sleep(.5)
	return MIN_DISTANCE < LAST_PCL
	

def forward(x=.5):
	move(x, 0)

def right(z=.5):
	move(0, z)

def left(z=.5):
	move(0, z)

def backward(x=.5):
	move(x, 0)

def move(x, z):
	twist = Twist()
	twist.linear.x = x
	twist.angular.z = z
	rospy.loginfo("Move({}, {})".format(x, z))
	_twist_publisher.publish(twist)
