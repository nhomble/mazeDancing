#!/usr/bin/env python2

import math
import time
import sys

from consts import *

import rospy
from roslib import message

from nav_msgs.msg import Odometry

from sensor_msgs.msg import PointCloud2, PointField, LaserScan
import point_cloud2 as pc2

import cv2
import cv2.cv as cv
from std_msgs.msg import Float64, Int64, String
from std_msgs.msg import Float64MultiArray, MultiArrayLayout, MultiArrayDimension
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError
import SimpleCV
import numpy as np

class Sensor_Manager(object):
	def __init__(self):
		# need to init a node to subscribe 
		self._node = rospy.init_node(SENSOR_NODE)
		# PCL things
		#self._pcl_subscriber = rospy.Subscriber(PCL_SUB, PointCloud2, self.pcl_callback)
		self.scanner = rospy.Subscriber('/scan', LaserScan, self._scan_callback)
		self.spub = rospy.Publisher(SCAN_IO, Float64MultiArray)
		self.last_pcl = None

		# pubs
		#self.full_pcl_pub = rospy.Publisher(PCL_FULL_IO, Float64MultiArray)
		#self.left_bias_pcl = rospy.Publisher(PCL_LEFT_IO, Float64MultiArray)
		#self.right_bias_pcl = rospy.Publisher(PCL_RIGHT_IO, Float64MultiArray)
		#self.middle_bias_pcl = rospy.Publisher(PCL_MIDDLE_IO, Float64MultiArray)


		#self._throttle = 0
	
	def _scan_callback(self, data):
		s = 0
		lp = 8
		i = 0
		part = [0 for _ in range(lp)]
		length = len(data.ranges)
		for d in data.ranges:
			index = i // (length/lp)
			if not math.isnan(d):
				s += d
				part[index] += d
			i += 1
		part = map(lambda x: lp * x/length, part)
#		print("{:.5} {:.5} {:.5} {:.5} {:.5} {:.5} {:.5} {:.5} {:.5}".format(s/length, \
#			float(part[0]), float(part[1]), float(part[2]), float(part[3]), float(part[4]), float(part[5]), float(part[6]), float(part[7])))

		part.append(s/length)
		self.spub.publish(_create_message_array(part))

	def pcl_callback(self, data):
		print("callback")
		if self._throttle == 0:
			self.last_pcl = data
			self._throttle += 1
		else:
			self._throttle = (self._throttle + 1) % 5
			return
		width = self.last_pcl.width
		height = self.last_pcl.height
		middle = (PCL_X_MAX + PCL_X_MIN) / 2
		data_out = pc2.read_points(self.last_pcl, skip_nans=True)
		# front, left, right, full
		sums = [0, 0, 0, 0]
		nums = [0, 0, 0, 0]
		sq_sums = [0, 0, 0, 0]
		within = [0, 0, 0, 0]
		good_range = lambda point: True if point[1] > PCL_Y_MIN and point[1] < PCL_Y_MAX else False
		valids = [\
				lambda point: True if point[0] > PCL_X_MIN and point[0] < PCL_X_MAX and \
					good_range(point) else False,\
				lambda point: True if point[0] >= middle and\
					good_range(point) else False,\
				lambda point: True if point[0] <= middle and\
					good_range(point) else False\
			]
		# (x,y,_) are not what you think..
		# there is some translation going on
		data_out = list(data_out)
		for points in data_out[::PCL_INTERVAL]:
			# rospy.loginfo(points)
			if valids[0](points):
				sums[0] += points[2]
				nums[0] += 1
				sq_sums[0] += math.pow(points[2], 2)
				within[0] += 1 if points[2] < MAX_DIST else 0
			if valids[1](points):
				sums[1] += points[2]
				nums[1] += 1
				sq_sums[1] += math.pow(points[2], 2)
				within[1] += 1 if points[2] < MAX_DIST else 0
			if valids[2](points):
				sums[2] += points[2]
				nums[2] += 1
				sq_sums[2] += math.pow(points[2], 2)
				within[2] += 1 if points[2] < MAX_DIST else 0
			sums[3] += points[2]
			nums[3] += 1
			sq_sums[3] += math.pow(points[2], 2)
			within[3] += 1 if points[2] < MAX_DIST else 0


		# no nums should be 0
		if nums[3] > 1:
			_avg = sums[3] / nums[3]
			_variance = (sq_sums[3] - (math.pow(_avg, 2)/nums[3]))/(nums[3]-1)
			self.full_pcl_pub.publish(_create_message_array(_avg, math.sqrt(_variance), nums[3], within[3]))
		else:
			self.full_pcl_pub.publish(_create_message_array(0, 2*MAX_STD_DEV, nums[3], within[3]))
		if nums[0] > 1:
			_avg = sums[0] / nums[0]
			_variance = (sq_sums[0] - (math.pow(_avg, 2)/nums[0]))/(nums[0]-1)
			self.middle_bias_pcl.publish(_create_message_array(_avg, math.sqrt(_variance), nums[0], within[0]))
		else:
			self.full_pcl_pub.publish(_create_message_array(0, 2*MAX_STD_DEV, nums[0], within[0]))
		if nums[1] > 1:
			_avg = sums[1] / nums[1]
			_variance = (sq_sums[1] - (math.pow(_avg, 2)/nums[1]))/(nums[1]-1)
			self.left_bias_pcl.publish(_create_message_array(_avg, math.sqrt(_variance), nums[1], within[1]))
		else:
			self.full_pcl_pub.publish(_create_message_array(0, 2*MAX_STD_DEV, nums[1], within[1]))
		if nums[2] > 1:
			_avg = sums[2] / nums[2]
			_variance = (sq_sums[2] - (math.pow(_avg, 2)/nums[2]))/(nums[2]-1)
			self.right_bias_pcl.publish(_create_message_array(_avg, math.sqrt(_variance), nums[2], within[2]))
		else:
			self.full_pcl_pub.publish(_create_message_array(1000, 1000, nums[2], within[2]))

def _create_message_array(arr):
	Float64MultiArray, MultiArrayLayout, MultiArrayDimension
	dim = MultiArrayDimension()
	dim.label = "{} length scan data".format(len(arr))
	dim.size = len(arr)
	dim.stride = 1 
	layout = MultiArrayLayout()
	layout.data_offset = 0
	layout.dim = [dim]
	message = Float64MultiArray()
	message.data = arr
	message.layout = layout
	return message
		
def main():
	manager = Sensor_Manager()
	while not rospy.is_shutdown():
		rospy.Rate(10).sleep()

if __name__ == "__main__":
	try:
		sys.exit(main())
	except rospy.ROSInterruptException:
		pass
