#!/usr/bin/env python2

import math
import time
import sys

from consts import *

import rospy
import roslib; roslib.load_manifest('mazeDancing')
from roslib import message

from sensor_msgs.msg import LaserScan

from std_msgs.msg import Float64, Int64, String
from std_msgs.msg import Float64MultiArray, MultiArrayLayout, MultiArrayDimension

class Sensor_Manager(object):
	def __init__(self):
		# need to init a node to subscribe 
		self._node = rospy.init_node(SENSOR_NODE)
		self.scanner = rospy.Subscriber('/scan', LaserScan, self._scan_callback)
		self.spub = rospy.Publisher(SCAN_IO, Float64MultiArray)
	
	# condense the depth scan into lp partitions
	def _scan_callback(self, data):
		start_angle = data.angle_min
		end_angle = data.angle_max
		angle_increment = data.angle_increment

		# determine points we should skip
		skip_l = (abs(start_angle) - RAD_ANGLE) / angle_increment
		skip_r = (end_angle - RAD_ANGLE) / angle_increment
		skip_a = int((skip_l + skip_r) // 2)
		skip_a = 0

		s = 0
		lp = NUM_LASER_PARTITIONS
		i = 0
		part = [0 for _ in range(lp)]
		length = len(data.ranges)
		#rospy.loginfo("{} {}".format(length, skip_a))
		for d in data.ranges[skip_a:length-skip_a]:
			index = i // (length/lp)
			if not math.isnan(d):
				s += d
				part[index] += d
			i += 1
		part = map(lambda x: lp * x/length, part)
		#rospy.loginfo("{:.5} {:.5} {:.5} {:.5} {:.5} {:.5} {:.5} {:.5} {:.5}".format(s/length, \
		#	float(part[0]), float(part[1]), float(part[2]), float(part[3]), float(part[4]), float(part[5]), float(part[6]), float(part[7])))
		#rospy.loginfo(str(data.ranges[length-skip_a:length]))

		part.append(s/length)
		self.spub.publish(_create_message_array(part))

def _create_message_array(arr):
	Float64MultiArray, MultiArrayLayout, MultiArrayDimension
	dim = MultiArrayDimension()
	dim.label = "{} length scan data".format(len(arr))
	dim.size = len(arr)
	dim.stride = 1 
	layout = MultiArrayLayout()
	layout.data_offset = 0
	layout.dim = [dim]
	message = Float64MultiArray()
	message.data = arr
	message.layout = layout
	return message
		
def main():
	manager = Sensor_Manager()
	while not rospy.is_shutdown():
		rospy.Rate(10).sleep()

if __name__ == "__main__":
	try:
		sys.exit(main())
	except rospy.ROSInterruptException:
		pass
