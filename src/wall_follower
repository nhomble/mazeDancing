#!/usr/bin/env python2

import time
import sys

# ROS specifoc
import roslib; roslib.load_manifest('mazeDancing')
import rospy
from std_msgs.msg import String

# my modules
from Move_Manager  import *

done = False
def tag_callback(data):
	global done
	if len(data.markers) > 0 and data.markers[0].id == 2:
		done = True

def wall_follower(move, maze, speech, stall=4):
	sub = rospy.Subscriber('/ar_pose_marker', AlvarMarkers, _tag_callback)
	speech.publish("start")
	while not done:
		speech.publish("find nodes")
		speech.publish("")
		speech.publish("check left")
		move.move(Direction.LEFT)
		if move.check(Direction.LEFT):
			maze.mark_ahead()
		speech.publish("check ahead")
		move.move(Direction.RIGHT)
		if move.check(Direction.FORWARD):
			maze.mark_ahead()
		speech.publish("check right")
		move.move(Direction.RIGHT)
		if move.check(Direction.RIGHT):
			maze.mark_ahead()
		speech.publish("now follow right wall")
		d = maze.next_pos()
		if d == Direction.RIGHT:
			move.move(Direction.FORWARD)
		elif d == Direction.FORWARD:
			move.move(Direction.LEFT)
			move.move(Direction.FORWARD)
		elif d == Direction.LEFT:
			move.move(Direction.LEFT)
			move.move(Direction.LEFT)
			move.move(Direction.FORWARD)
		elif d == Direction.BACKWARD:
			move.move(Direction.RIGHT)
			move.move(Direction.FORWARD)
	sub.unregister()
	speech.publish("now backtrack")
	maze.print_maze()
	

# take N steps
def right_wall_follower(move, maze, speech, N=7, stall=5):
	speech.publish("start")
	for _ in range(N):
		speech.publish(str(_))
		rospy.loginfo("check right")
		## check right
		# turn right
		speech.publish("check right")
		move.move(Direction.RIGHT)
		time.sleep(stall)
		# check the right side of depth cloud
		if move.check(Direction.RIGHT):
			speech.publish("its open")
			rospy.loginfo("move forward because gap in wall")
			move.move(Direction.FORWARD)
			continue
		rospy.loginfo("nudge")
		# we got a wall, so adjust a little to be at goal distance
		#move.nudge()
		# reset
		speech.publish("reset left")
		rospy.loginfo("reset left")
		move.move(Direction.LEFT)
		time.sleep(stall)
		## check forward
		speech.publish("check forward")
		if move.check(Direction.FORWARD):
			rospy.loginfo("forward")
			move.move(Direction.FORWARD)
		else:
			rospy.loginfo("turn left cause ahead is blocked")
			move.move(Direction.LEFT)
	move.maze.print_maze()
	path, _ = move.maze.best_path()
	print(path)
			

def checks(move):
	while True:
		print(move._checks)
		print("{} {} {}".format(move.check(Direction.FORWARD), move.check(Direction.LEFT), move.check(Direction.RIGHT)))
		rospy.Rate(5).sleep()

# ROS loop
def main():
	speech = rospy.Publisher(SPEECH_IO, String)
	move = Move_Manager()
	maze = Maze()
	right_wall_follower(move, maze, speech)
	#checks(move)
	return 

if __name__ == "__main__":
	try:
		rospy.init_node('wall_follower')
		sys.exit(main())
	except rospy.ROSInterruptException:
		pass
