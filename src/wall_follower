#!/usr/bin/env python2

import time
import sys

# ROS specifoc
import roslib; roslib.load_manifest('mazeDancing')
import rospy
from std_msgs.msg import String
from ar_track_alvar.msg import *

# my modules
from Move_Manager  import *
from Dance import *

done = False
def _tag_callback_end(data):
	global done
	if len(data.markers) > 0 and data.markers[0].id == 2:
		done = True

def _tag_callback_start(data):
	global done
	if len(data.markers) > 0 and data.markers[0].id == 1:
		done = True

def _get_directions(openings):
	if openings[2]:
		return Direction.RIGHT
	elif openings[1]:
		return Direction.FORWARD
	elif openings[0]:
		return Direction.LEFT
	else:
		return Direction.BACKWARD

def _do_move(d, move, speech):
	if d == Direction.RIGHT:
		move.move(d)
		move.move(Direction.FORWARD)
	elif d == Direction.FORWARD:
		move.move(Direction.LEFT)
		move.move(d)
	elif d == Direction.LEFT:
		move.move(d)
		move.move(d)
		move.move(Direction.FORWARD)
	elif d == Direction.BACKWARD:
		move.move(Direction.RIGHT)
		move.move(Direction.FORWARD)

def _tuch(direction, move, stall):
	if direction == Direction.LEFT or direction == Direction.RIGHT:
		move.move(direction)
	time.sleep(stall)
	return move.check(direction)

def demo_scout(move, speech, stall):
	pass

def demo_worker(move, speech, stall):
	pass

def demo(move, speech, stall, is_scout=True):
	# re-do
	if is_scout:
		demo_scout(move, speech, stall)
	else:
		demo_worker(move, speech, stall)
	pass

# just test the feedback and tag detection
def practice(move,  speech, stall=.5):
	time.sleep(1)
	speech.publish("check left")
	move.move(Direction.LEFT)
	speech.publish("left is blocked")
	speech.publish("check ahead")
	move.move(Direction.RIGHT)
	speech.publish("ahead is open")
	speech.publish("check right")
	move.move(Direction.RIGHT)
	speech.publish("right is block")
	speech.publish("follow right wall")
	move.move(Direction.LEFT)
	speech.publish("go forward")
	move.move(Direction.FORWARD)
	move.maze.print_maze()

	speech.publish("check left")
	move.move(Direction.LEFT)
	speech.publish("left is open")
	speech.publish("check ahead")
	move.move(Direction.RIGHT)
	speech.publish("ahead is blocked")
	speech.publish("check right")
	move.move(Direction.RIGHT)
	speech.publish("right is open")
	speech.publish("follow right wall")
	speech.publish("go right")
	move.move(Direction.FORWARD)
	move.maze.print_maze()
	move.check(Direction.FORWARD)

	'''
	speech.publish("check left")
	move.move(Direction.LEFT)
	speech.publish("left is blocked")
	speech.publish("check ahead")
	move.move(Direction.RIGHT)
	speech.publish("ahead is open")
	speech.publish("check right")
	move.move(Direction.RIGHT)
	speech.publish("right is blocked")
	speech.publish("follow right wall")
	move.move(Direction.LEFT)
	speech.publish("go forward")
	move.move(Direction.FORWARD)
	'''

	speech.publish("check left")
	move.move(Direction.LEFT)
	speech.publish("left is blocked")
	speech.publish("check ahead")
	move.move(Direction.RIGHT)
	speech.publish("ahead is blocked")
	speech.publish("check right")
	move.move(Direction.RIGHT)
	speech.publish("right is blocked")
	speech.publish("follow right wall")
	speech.publish("go backward")
	move.move(Direction.RIGHT)
	move.move(Direction.FORWARD)
	move.maze.print_maze()

	'''
	speech.publish("check left")
	move.move(Direction.LEFT)
	speech.publish("left is blocked")
	speech.publish("check ahead")
	move.move(Direction.RIGHT)
	speech.publish("ahead is open")
	speech.publish("check right")
	move.move(Direction.RIGHT)
	speech.publish("right is blocked")
	speech.publish("follow right wall")
	move.move(Direction.LEFT)
	speech.publish("go forward")
	move.move(Direction.FORWARD)
	'''

	speech.publish("check left")
	move.move(Direction.LEFT)
	speech.publish("left is open")
	speech.publish("check ahead")
	move.move(Direction.RIGHT)
	speech.publish("ahead is open")
	speech.publish("check right")
	move.move(Direction.RIGHT)
	speech.publish("right is blocked")
	speech.publish("follow right wall")
	move.move(Direction.LEFT)
	speech.publish("go forward")
	move.move(Direction.FORWARD)

	speech.publish("we have reached goal")
	move.maze.print_maze()
	path1, path2 = move.maze.best_path()
	str1 = "RETURN PATH: "
	str2 = "WORKER PATH: "
	for p in path1:
		str1 += Direction.to_string[p]
	for p in path2:
		str2 += Direction.to_string[p]
	print(str1)
	print(str2)

def wall_follower(move, speech, stall=.5):
	global done
	sub = rospy.Subscriber('/ar_pose_marker', AlvarMarkers, _tag_callback_end)
	speech.publish("start")
	while not done:
		openings = [False, False, False]
		speech.publish("find nodes")
		speech.publish("")
		speech.publish("check left")
		if _tuch(Direction.LEFT, move, stall):
			speech.publish("LEFT IS OPEN")
			move.maze.mark_ahead()
			openings[0] = True

		move.move(Direction.RIGHT)
		speech.publish("check ahead")
		if _tuch(Direction.FORWARD, move, stall):
			speech.publish("FORWARD IS OPEN")
			move.maze.mark_ahead()
			openings[1] = True

		speech.publish("check right")
		if _tuch(Direction.RIGHT, move, stall):
			speech.publish("RIGHT IS OPEN")
			move.maze.mark_ahead()
			openings[2] = True

		speech.publish("now follow right wall")

		d = _get_directions(openings)
		if not done:
			_do_move(d, move, speech)
		else:
			speech.publish("found goal")

	speech.publish("now backtrack")
	move.move(Direction.LEFT)
	move.move(Direction.LEFT)
	sub.unregister()
	sub = rospy.Subscriber('/ar_pose_marker', AlvarMarkers, _tag_callback_start)
	done = False
	step = 0
	path, worker = move.maze.best_path()
	while not done:
		options = 0
		coor = [False, False, False]
		if _tuch(Direction.LEFT, move, stall):
			options += 1
			coor[0] = True
		if _tuch(Direction.FORWARD, move, stall):
			options += 1
			coor[1] = True
		if _tuch(Direction.RIGHT, move, stall):
			options += 1
			coor[2] = True

		# node
		if options > 1:
			# HACK
			if step >= len(path):
				done = True
				continue
			d = path[step]
			step += 1
		else:
			d = _get_directions(coor)

		_do_move(d, move, speech)

	# turn right to the other robot
	move.move(Direction.RIGHT)
	do_dance(worker, move)
	# reverse
	move.move(Direction.LEFT)
	move.move(Direction.LEFT)
	# leave
	move.move(Direction.FORWARD)
	move.move(Direction.FORWARD)

# take N steps
def right_wall_follower(move, maze, speech, N=7, stall=5):
	speech.publish("start")
	for _ in range(N):
		speech.publish(str(_))
		rospy.loginfo("check right")
		## check right
		# turn right
		speech.publish("check right")
		move.move(Direction.RIGHT)
		time.sleep(stall)
		# check the right side of depth cloud
		if move.check(Direction.RIGHT):
			speech.publish("its open")
			rospy.loginfo("move forward because gap in wall")
			move.move(Direction.FORWARD)
			continue
		rospy.loginfo("nudge")
		# we got a wall, so adjust a little to be at goal distance
		#move.nudge()
		# reset
		speech.publish("reset left")
		rospy.loginfo("reset left")
		move.move(Direction.LEFT)
		time.sleep(stall)
		## check forward
		speech.publish("check forward")
		if move.check(Direction.FORWARD):
			rospy.loginfo("forward")
			move.move(Direction.FORWARD)
		else:
			rospy.loginfo("turn left cause ahead is blocked")
			move.move(Direction.LEFT)
	move.maze.print_maze()
	path, _ = move.maze.best_path()
	print(path)
			

def checks(move):
	while True:
		print(move._checks)
		print("{} {} {}".format(move.check(Direction.FORWARD), move.check(Direction.LEFT), move.check(Direction.RIGHT)))
		rospy.Rate(5).sleep()

# ROS loop
def main():
	speech = rospy.Publisher(SPEECH_IO, String)
	move = Move_Manager()
	#wall_follower(move, speech)
	#checks(move)
	practice(move, speech)
	return 

if __name__ == "__main__":
	try:
		rospy.init_node('wall_follower')
		sys.exit(main())
	except rospy.ROSInterruptException:
		pass
